---
title: "Shape analysis for ISSA"
author: "Junhui He"
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: yes
    number_sections: yes
editor_options:
  chunk_output_type: console
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
# Load required libraries
library(knitr)
library(patchwork)
library(tidyverse)
library(scales)
library(uwot)
library(mclust)
library(openxlsx)

# Set global chunk options for the document
knitr::opts_chunk$set(
  echo = FALSE,        # Don't show code in output
  include = TRUE,      # Include output
  eval = TRUE,         # Evaluate code chunks
  warning = FALSE,     # Don't show warnings
  message = FALSE,     # Don't show messages
  fig.retina = 2,      # Higher resolution figures
  fig.width = 8,       # Default figure width
  fig.height = 6,      # Default figure height
  out.width = "100%"   # Full width in HTML output
)
```

# Introduction to the ISSA Dataset

The International Skin Spectra Archive (ISSA) offers a detailed collection of spectral and colorimetric data for human skin, encompassing 15,256 records from 2,113 subjects. This data spans from 2012 to 2024 and originates from eleven datasets curated by international laboratories across eight countries: the UK, Spain, China, Japan, Pakistan, Thailand, Iraq, and Saudi Arabia. Each dataset follows a standardised measurement protocol to maintain data consistency.

In the ISSA dataset, individual records provide extensive details including record number, data origin, subject identification, and skin typeâ€”categorised by ethnicity, gender, age, and body location. The dataset also includes detailed information on the measurement instruments used, such as type, specular component inclusion, wavelength range and interval.

Alongside spectral data, each sample also contains CIE colorimetric data, including tristimulus values, xy chromaticity coordinates, CIELAB parameters, etc., based on the CIE 1931 standard colorimetric observer and the CIE standard illuminant D65.

## Data Records

The datasheet arranges data across columns labelled A to BQ:

-   A: Unique record identifier
-   B: Data origin
-   C: Subject number
-   D to G: Ethnicity, gender, age group, and body location
-   H to L: Instrument details including type and spectral measurement specifics
-   N to BD: Spectral data from 360 nm to 780 nm
-   BF to BQ: CIE colorimetric data

## Skin Type

-   **Ethnicity**: CA (Caucasian), CN (Chinese), SA (South Asian), AF (African), IQ (Iraqi), TH (Thai), JP (Japanese), AB (Arabian)
-   **Gender**: F (Female), M (Male)
-   **Body Location**: 1 (Back of Hand), 2 (Cheek), 3 (Cheek bone), 4 (Chin), 5 (Ear Lobe), 6 (Forehead), 7 (Inner arm), 8 (Neck), 9 (Nose tip), 10 (Outer arm), 11 (Palm), 12 (Ring finger)

## Visualization

```{r load_issa}
# Load the ISSA skin spectrum reflectance data
# issa_path <- "G:/Phd/Colloborator/Tina Lasisi/Meta/ISSA_17_Jan_2025_Yan_Lu.xlsx"
issa_path <- "/Users/hjh/PhD/Meta/ISSA_17_Jan_2025_Yan_Lu.xlsx"
issa_code <- read.xlsx(issa_path, sheet = 1)
issa_data <- read.xlsx(issa_path, sheet = 2)

# Extract the skin spectrum data
issa <- issa_data[10:nrow(issa_data), ] # 360 nm: 13rd column, 780 nm: 55th column
colnames(issa) <- issa_data[9, ]
```

```{r util_plot_functions}
# ==============================================================================
# DATA PROCESSING FUNCTIONS
# ==============================================================================

#' Calculate melanin index and prepare data for plotting
#' 
#' This function:
#' 1. Calculates the melanin index (CMI) using wavelengths 640-670nm
#' 2. Filters data to reasonable CMI range (20-130)
#' 3. Samples data to prevent plot overload
#' 4. Converts to long format for ggplot
#' 
#' @param data Processed spectral data frame
#' @param sample_size Number of spectra to sample (default 400)
#' @return Long-format data frame with id, wavelength, reflectance, and cmi
calculateMIndex <- function(data) {
  # Calculate melanin index using the formula from the literature
  # This uses the red region of the spectrum (640-670nm)
  data_processed <- data %>% 
    mutate(
      # Average reflectance in the red region
      eqn1 = ((`650` + `660` + (0.5 * `640`) + (0.5 * `660`)) / 3) / 100,
      # Convert to melanin index
      cmi = 100 * log10(1 / eqn1)
    )
  
  # Prepare data for plotting
  data_long <- data_processed %>%
    #mutate(id = row_number()) %>%
    # Filter to reasonable melanin index range
    # filter(cmi >= 20 & cmi <= 130) %>% 
    # Sample to prevent plot overload
    # slice_sample(n = sample_size) %>% 
    # Convert to long format
    pivot_longer(cols = matches("^[0-9]+$"), 
                 names_to = "wavelength", 
                 values_to = "reflectance") %>% 
    # Extract numeric wavelength values
    mutate(wavelength = as.numeric(str_remove(wavelength, "\\D+"))) %>% 
    # Focus on visible spectrum
    filter(wavelength >= 400 & wavelength <= 700) # %>%
    # select(id, everything())
  
  return(data_long)
}

# ==============================================================================
# PLOTTING FUNCTIONS
# ==============================================================================

#' Generate skin spectra plot
#' 
#' Creates a plot showing reflectance spectra colored by melanin index
#' 
#' @param data Long-format data with wavelength, reflectance and cmi
#' @return A ggplot object
PlotSkinSpectra <- function(data) {
  plot <- ggplot(data, aes(x = wavelength, y = reflectance, group = A,
                          color = cmi)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
    expand_limits(y = 0) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Reflectance percentage of skin",
      color = "Melanin index"
    ) +
    guides(color = guide_colorbar(reverse = TRUE)) +
    # Highlight the region used for melanin index calculation
    annotate("rect", xmin = 640, xmax = 670, ymin = 0, ymax = 70,
             alpha = 0.3, fill = "#ff0000")
  
  return(plot)
}

#' Wrapper function to process file and generate plot
#' 
#' @param file_name Path to the CSV file
#' @return A ggplot object
PlotSkinSpectraWrapper <- function(data) {
  
  # Calculate melanin index
  data_with_mindex <- calculateMIndex(data)
  
  # Generate the plot
  plot <- PlotSkinSpectra(data_with_mindex)
  
  return(plot)
}
```

We visualize the skin reflectance curves across all ethnicity and body locations in the following figure:

```{r plot_reflectance}
plot_reflectance = PlotSkinSpectraWrapper(issa) + labs(title = "ISSA skin reflectance curves", subtitle = "including all ethnicity and body locations")
plot_reflectance
```

Furthermore, we visualize the skin reflectance curves per body location in the following figure:

```{r plot_body, fig.height=12}
bodys = as.character(1:12)
body_names = c("Back of Hand", "Cheek", "Cheek bone", "Chin", "Ear Lobe", "Forehead", "Inner arm", "Neck", "Nose tip", "Outer arm", "Palm", "Ring finger")

plots_body_list = list()
for (iloc in bodys) {
  issa_body = issa %>% filter(G == iloc)
  plot_body = PlotSkinSpectraWrapper(issa_body) + labs(title = body_names[as.numeric(iloc)])
  plots_body_list[[iloc]] = plot_body
}

wrap_plots(plots_body_list, ncol = 3, guides = "collect") + plot_annotation(title = "ISSA skin reflectance curves", subtitle = "vary among body locations") & theme(
    legend.position = "bottom")
```

# Derivative analysis

## First derivative

We calculate the derivatives of the function to measure its growth rate. Since the skin reflectance is evaluated at a equally spaced wavelengths, i.e., $\{300,310,\ldots,690,700\}$, we calculate the differences in function values to represent the derivatives.

```{r finite_diff}
# finite differences
dy = t(diff(t(issa %>% select("400":"700")))) # first derivative
ddy = t(diff(t(dy))) # second derivative

# plot the first derivatives
PlotDerivative <- function(data) {
  # Prepare data for plotting
  data_long <- data %>%
    # Convert to long format
    pivot_longer(cols = matches("^[0-9]+$"), 
                 names_to = "wavelength", 
                 values_to = "delta") %>% 
    # Extract numeric wavelength values
    mutate(wavelength = as.numeric(str_remove(wavelength, "\\D+"))) %>% 
    # Focus on visible spectrum
    filter(wavelength >= 400 & wavelength <= 700) # %>%
    
  plot <- ggplot(data_long, aes(x = wavelength, y = delta, group = A,
                          color = cmi)) +
    geom_line(alpha = 0.6) +  # Add transparency to handle overlapping lines
    geom_hline(yintercept = 0, color = "red") +
    # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
    expand_limits(y = 0) +
    theme_classic() +
    labs(
      x = "Wavelength (nm)",
      y = "Derivatives of skin reflectance percentage",
      title = "First derivatives of skin reflectance percentage",
      color = "Melanin index"
    ) +
    guides(color = guide_colorbar(reverse = TRUE))
  
  return(plot)
}

issa = issa %>% 
    mutate(
      # Average reflectance in the red region
      eqn1 = ((`650` + `660` + (0.5 * `640`) + (0.5 * `660`)) / 3) / 100,
      # Convert to melanin index
      cmi = 100 * log10(1 / eqn1)
    )

dy_df = as.data.frame(dy) %>% mutate(A = issa$A, cmi = issa$cmi)
plot_derivative = PlotDerivative(dy_df)
plot_derivative
```

## Variations in the first derivatives

We observe that higher curves tend to be more oscillatory, whereas lower curves appear flatter. To examine this pattern, we compute the standard deviation of the first derivatives as a measure of oscillation. The figures below show a clear positive relationship between the variation of the first derivatives and the average reflectance, or a negative relationship between the variation of the first derivatives and melanin index.

```{r var_in_derivatice, fig.height=5}
ave = rowMeans(issa %>% select("400":"700")) # average reflectance
sd_der = apply(dy, 1, sd) # standard deviation in first derivatives

plot1_var = ggplot() +
  geom_point(aes(x = ave, y = sd_der), size = 0.5) +
  theme_classic() +
  labs(
    x = "Average reflectance",
    y = "Standard deviation in first derivatives",
    title = "Oscillation versus average reflectance"
  )

plot2_var = ggplot() +
  geom_point(aes(x = issa$cmi, y = sd_der), size = 0.5) +
  theme_classic() +
  labs(
    x = "Melanin index",
    y = "Standard deviation in first derivatives",
    title = "Oscillation versus melanin index"
  )

plot1_var + plot2_var
```

# Sliding window approaches

We use sliding windows to extract local features of the skin reflectance curves. Specifically, we consider a window size of 60 nm and slide the window from 400 nm to 700 nm with a step size of 30 nm. In each window, we calculate the average reflectance and slope. Therefore, we transform the original skin reflectance curves to 18-dimensional vectors.

```{r sliding_window}
# sliding window approach
issa_visible = issa %>% select("400":"700")
window_size = 6
step_size = 3
start_wavelengths = seq(1, 31 - window_size + 1, by = step_size)
sliding_window_features = array(NA, dim = c(nrow(issa_visible), length(start_wavelengths) * 2))
for (i in 1:nrow(issa_visible)) {
  for (j in seq_along(start_wavelengths)) {
    start = start_wavelengths[j]
    end = start + window_size - 1
    seg = c(as.matrix(issa_visible[i, start:end]))
    seg_wave = seq(1, window_size) * 10 # wavelength in nm
    fit = lm(seg ~ seg_wave)
    sliding_window_features[i, j] = mean(seg) # average reflectance
    sliding_window_features[i, j + length(start_wavelengths)] = coef(fit)[2] # slope
  }
}
```

## Dimension reduction

We apply UMAP to reduce the dimension of the sliding window features from 18 to 2. The figure below shows the UMAP results colored by ethnicity and body locations, respectively. Based on the UMAP figure, it is difficult to distinguish the ethnicity and body locations through the sliding window features.

```{r umap_sliding_window, fig.height=6}
set.seed(123)
umap_result = umap(sliding_window_features, n_neighbors = 30, n_components = 2, min_dist = 0.1, scale = TRUE)
umap_df = data.frame(UMAP1 = umap_result[,1], UMAP2 = umap_result[,2], ethnicity = issa$D, body = factor(as.numeric(issa$G)))

umap_df$cmi = issa$cmi

ggplot(umap_df, aes(UMAP1, UMAP2, color = cmi)) +
  geom_point(alpha = 0.6, size = 0.5) +
  # Color gradient from dark to light skin
    scale_color_gradientn(
      colours = c("#42230c", "#a15c33", "#fbf7ec"),
      values = rescale(x = c(50, 40, 20)),
      oob = squish,
      limits = c(20, 130)
    ) +
  labs(
    color = "Menalin index"
  ) +
  theme_classic() +
  theme(legend.position = "bottom") +
  guides(color = guide_colorbar(reverse = TRUE))
  

# plot umap results colored by ethnicity and body locations
plot1_umap = ggplot(umap_df, aes(UMAP1, UMAP2, color = ethnicity)) +
  geom_point(alpha = 0.6, size = 0.5) +
  labs(
    color = "Ethnicity"
  ) +
  theme_classic() +
  theme(legend.position = "bottom")

plot2_umap = ggplot(umap_df, aes(UMAP1, UMAP2, color = body)) +
  geom_point(alpha = 0.6, size = 0.5) +
  labs(
    color = "Body location"
  ) +
  theme_classic() +
  theme(legend.position = "bottom")

wrap_plots(plot1_umap, plot2_umap, ncol = 2) + plot_annotation(title = "UMAP of sliding-window features", subtitle = paste0("W = 60 nm, step = 30 nm | n_windows = ", length(start_wavelengths)))
```

## Gaussian mixture model

We fit a Gaussian mixture model (GMM) to the 18-dimensional sliding window features using `mclust`. The number of components is selected as 12. The figure below shows the UMAP results colored by GMM clusters.

```{r gmm_sliding_window}
set.seed(123)
gmm_fit = Mclust(scale(sliding_window_features), G = 12)

# plot umap results colored by GMM clusters
umap_df$cluster = factor(gmm_fit$classification)
ggplot(umap_df, aes(UMAP1, UMAP2, color = cluster)) +
  geom_point(alpha = 0.6, size = 0.5) +
  labs(
    title = "UMAP of sliding-window features",
    subtitle = paste0("W = 60 nm, step = 30 nm | n_windows = ", length(start_wavelengths)),
    color = "GMM cluster"
  ) +
  theme_classic() +
  theme(legend.position = "bottom")
```

# Next steps

We can train a deep learningâ€“based classifier to decide whether a reflectance curve is realistic, using the sliding-window features as input. One approach is to employ a generative adversarial network (GAN), training the generator and discriminator together. After training, the discriminator can serve as a classifier, distinguishing realistic reflectance curves from unrealistic ones.
